(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{513:function(a,t,s){"use strict";s.r(t);var r=s(2),e=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")]),a._v(" "),t("img",{attrs:{src:"https://markdown-1301334775.cos.eu-frankfurt.myqcloud.com/image-20230425113337990.png",alt:"image-20230425113337990"}})]),a._v(" "),t("p",[t("strong",[a._v("Vector和ArrayList：")])]),a._v(" "),t("ol",[t("li",[t("p",[a._v("Vector是线程安全的，因为大部分方法都用syncronized方法修饰，而ArrayList不是")])]),a._v(" "),t("li",[t("p",[a._v("ArrayList在原来的数组不够用的时候扩容0.5倍，Vector扩容1倍")])])]),a._v(" "),t("p",[a._v("所以单线程环境下，Vector的效率很低，而在多线程环境中不能直接用ArrayList，必须加处理")]),a._v(" "),t("p",[t("strong",[a._v("HashMap和HashTable：")])]),a._v(" "),t("ol",[t("li",[t("p",[a._v("Hashtable中方法是synchronized，多线程可以直接用Hashtable，而HashMap必须手动处理。")])]),a._v(" "),t("li",[t("p",[a._v("Hashtable的key和value都允许null值，而HashMap中null只能作为键，并且只有一个。")])]),a._v(" "),t("li",[t("p",[a._v("Hashtable直接使用对象的hashcode，而HashMap是另外计算了hash值。")])]),a._v(" "),t("li",[t("p",[a._v("Hashtable的hash数组初始大小为11，增加方式是old*2+1，而hashMap中默认数组的大小为16，而且一定是2的指数。")])])]),a._v(" "),t("p",[t("strong",[a._v("TreeMap和HashMap：")])]),a._v(" "),t("ol",[t("li",[a._v("TreeMap继承自SortedMap，HashMap继承自Abstractap，TreeMap会把元素排序，所以更适合按自然顺序遍历元素，其他情况HashMap更常用，因为效率更高")])]),a._v(" "),t("p",[t("strong",[a._v("HashMap和HashSet：")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://markdown-1301334775.cos.eu-frankfurt.myqcloud.com/image-20230425113412190.png",alt:"image-20230425113412190"}})])])}),[],!1,null,null,null);t.default=e.exports}}]);