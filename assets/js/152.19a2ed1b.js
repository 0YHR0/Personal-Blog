(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{548:function(t,e,O){"use strict";O.r(e);var r=O(2),n=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"commonobject"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commonobject"}},[t._v("#")]),t._v(" CommonObject")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://markdown-1301334775.cos.eu-frankfurt.myqcloud.com/image-20230425113521966.png",alt:"image-20230425113521966"}})]),t._v(" "),e("p",[t._v("ORM是对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序设计"),e("OutboundLink")],1),t._v("技术，用于实现"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1",target:"_blank",rel:"noopener noreferrer"}},[t._v("面向对象"),e("OutboundLink")],1),t._v("编程语言里不同"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F",target:"_blank",rel:"noopener noreferrer"}},[t._v("类型系统"),e("OutboundLink")],1),t._v("的数据之间的转换。")]),t._v(" "),e("p",[e("strong",[t._v("第 1 个：DAO")])]),t._v(" "),e("p",[t._v("DAO（Data Access Object）数据访问对象，它是一个面向对象的数据库接口，负责持久层的操作，为业务层提供接口，主要用来封装对数据库的访问，常见操作无外乎 CURD。我们也可以认为一个 DAO 对应一个 POJO 的对象，它位于业务逻辑与数据库资源中间，可以结合 PO 对数据库进行相关的操作。")]),t._v(" "),e("p",[e("strong",[t._v("第 2 个：PO")])]),t._v(" "),e("p",[t._v("PO（Persistent Object）持久层对象，它是由一组属性和属性的get和set方法组成，最简单的 PO 就是对应数据库中某个表中的一条记录（也就是说，我们可以将数据库表中的一条记录理解为一个持久层对象），多个记录可以用 PO 的集合，PO 中应该不包含任何对数据库的操作。PO 的属性是跟数据库表的字段一一对应的，此外 PO 对象需要实现序列化接口。")]),t._v(" "),e("p",[e("strong",[t._v("第 3 个：BO")])]),t._v(" "),e("p",[t._v("BO（Business Object）业务层对象，是简单的真实世界的软件抽象，通常位于中间层。BO 的主要作用是把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。举一个求职简历的例子，每份简历都包括教育经历、项目经历等，我们可以让教育经历和项目经历分别对应一个 PO，这样在我们建立对应求职简历的 BO 对象处理简历的时候，让每个 BO 都包含这些 PO 即可。")]),t._v(" "),e("p",[e("strong",[t._v("第 4 个：VO")])]),t._v(" "),e("p",[t._v("VO（Value Object）值对象，通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已，但 VO 应该是抽象出的业务对象，可以和表对应，也可以不对应，这根据业务的需要。 如果锅碗瓢盆分别为对应的业务对象的话，那么整个碗柜就是一个值对象。此外，VO 也可以称为页面对象，如果称为页面对象的话，那么它所代表的将是整个页面展示层的对象，也可以由需要的业务对象进行组装而来。")]),t._v(" "),e("p",[e("strong",[t._v("第 5 个：DTO")])]),t._v(" "),e("p",[t._v("DTO（Data Transfer Object）数据传输对象，主要用于远程调用等需要大量传输对象的地方，比如我们有一个交易订单表，含有 25 个字段，那么其对应的 PO 就有 25 个属性，但我们的页面上只需要显示 5 个字段，因此没有必要把整个 PO 对象传递给客户端，这时我们只需把仅有 5 个属性的 DTO 把结果传递给客户端即可，而且如果用这个对象来对应界面的显示对象，那此时它的身份就转为 VO。使用 DTO 的好处有两个，一是能避免传递过多的无用数据，提高数据的传输速度；二是能隐藏后端的表结构。常见的用法是：将请求的数据或属性组装成一个 RequestDTO，再将响应的数据或属性组装成一个 ResponseDTO.")]),t._v(" "),e("p",[e("strong",[t._v("第 6 个：POJO")])]),t._v(" "),e("p",[t._v("POJO（Plain Ordinary Java Object）简单的 Java 对象，实际就是普通的 JavaBeans，是为了避免和 EJB（Enterprise JavaBean）混淆所创造的简称。POJO 实质上可以理解为简单的实体类，其中有一些属性及其getter和setter方法的类，没有业务逻辑，也不允许有业务方法，也不能携带有connection之类的方法。POJO 是 JavaEE 世界里面最灵活的对象，在简单系统中，如果从数据库到页面展示都是 POJO 的话，它可以是 DTO；如果从数据库中到业务处理中都是 POJO 的话，它可以是 BO；如果从数据库到整个页面的展示的话，它也可以是 VO.")]),t._v(" "),e("p",[e("em",[t._v("扩展阅读：")])]),t._v(" "),e("p",[t._v("在实际的项目中，我们还会遇到一个常见的对象，那就是 Entity 实体对象，它对应数据库中的表，我们可以简单的理解为一个表对应一个 Entity，同样以交易订单表 Order 为例，如果这个表有 25 个字段，那么这个 OrderEntity 对象里面也要含有 25 个对应的属性。")])])}),[],!1,null,null,null);e.default=n.exports}}]);