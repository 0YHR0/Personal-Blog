(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{448:function(v,_,l){"use strict";l.r(_);var t=l(2),i=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("strong",[v._v("数组")])]),v._v(" "),_("p",[v._v("​     "),_("strong",[v._v("优点")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("随机访问快（可以通过下标迅速定位）")]),v._v(" "),_("li",[v._v("查找速度快")])]),v._v(" "),_("p",[v._v("​      ** 缺点**：")]),v._v(" "),_("ul",[_("li",[v._v("增加删除的效率低（可能需要大幅度移动数据）")]),v._v(" "),_("li",[v._v("内存空间不灵活，需要一整块的内存，也有可能浪费内存")]),v._v(" "),_("li",[v._v("扩展性差，大小在初始化时就指定好了")])]),v._v(" "),_("p",[_("strong",[v._v("链表:")])]),v._v(" "),_("p",[v._v("​      "),_("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("访问速度慢，需要从头开始遍历")])]),v._v(" "),_("p",[v._v("​      "),_("strong",[v._v("优点")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("插入删除的速度快")]),v._v(" "),_("li",[v._v("可扩展性强，大小不固定")]),v._v(" "),_("li",[v._v("内存空间是分散的")])]),v._v(" "),_("p",[_("strong",[v._v("单链表与双链表的区别：")])]),v._v(" "),_("ul",[_("li",[v._v("单链表在删除节点时需要一个temp，指针移动的复杂度为2i")]),v._v(" "),_("li",[v._v("双向链表可以用二分法查找")])]),v._v(" "),_("p",[_("strong",[v._v("哈希表：")])]),v._v(" "),_("p",[v._v("​       "),_("strong",[v._v("优点")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("插入/查询/删除效率非常高")])]),v._v(" "),_("p",[_("strong",[v._v("缺点")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("空间利用率不高，底层使用的是数组，并且使用的某些单元是没有被利用的")]),v._v(" "),_("li",[v._v("哈希表中的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素")]),v._v(" "),_("li",[v._v("不能快速的找出哈希表中的最大值或者最小值")])]),v._v(" "),_("p",[_("strong",[v._v("树结构：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("在某种场景下，使用树结构会更加方便")])]),v._v(" "),_("li",[_("p",[v._v("因为树结构是非线性，可以表示一对多")])]),v._v(" "),_("li",[_("p",[v._v("比如文件的目录结构")])]),v._v(" "),_("li",[_("p",[v._v("对于一个平衡树的插入和查找等效率为O(logN)   平衡树： 树两边的数据均匀分布 非平衡树： 树两边的数据不均匀分布")])]),v._v(" "),_("li",[_("p",[v._v("连续插入有序的数据，树分布不均匀，变成一个链表结构，插入和查找等效率变成 O(N)")])])]),v._v(" "),_("p")])}),[],!1,null,null,null);_.default=i.exports}}]);