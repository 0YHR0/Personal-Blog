(window.webpackJsonp=window.webpackJsonp||[]).push([[247],{645:function(e,i,t){"use strict";t.r(i);var a=t(2),p=Object(a.a)({},(function(){var e=this,i=e._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"processes"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#processes"}},[e._v("#")]),e._v(" Processes")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Processes in memory")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("text: 程序code")])]),e._v(" "),i("li",[i("p",[e._v("data：程序作用的数据，例：图像处理应用中的图像")])]),e._v(" "),i("li",[i("p",[e._v("heap：存储着程序执行暂时的数据")])]),e._v(" "),i("li",[i("p",[e._v("heap和stack的大小可以动态增长"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/41ede35f-83a1-43a0-aee7-0d45f21a5f2f-14899999.jpg",alt:"img"}})])])])]),e._v(" "),i("li",[i("p",[e._v("Process state"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/b4049725-d15b-4b4d-bd7e-dc63c607ad49-14899999.jpg",alt:"img"}}),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/e09971b8-2237-43bc-adee-ebd44a0e415c-14899999.jpg",alt:"img"}})])]),e._v(" "),i("li",[i("p",[e._v("Process control block（PCB）")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("每个process都有一个unique的PCB")])]),e._v(" "),i("li",[i("p",[e._v("同一个程序可以产生两个process，比如用word处理两份文档，但是PCB不可能相同")])]),e._v(" "),i("li",[i("p",[e._v("系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志")])]),e._v(" "),i("li",[i("p",[e._v("进程与PCB是一一对应的")])])])]),e._v(" "),i("li",[i("p",[e._v("Cpu调度process流程"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/2d7a327e-6153-465d-a180-5e79f3ea9fe9-14899999.jpg",alt:"img"}})])]),e._v(" "),i("li",[i("p",[e._v("Process scheduling"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/32b9225a-bd7d-42d3-9530-aeb3700b794f-14899999.jpg",alt:"img"}}),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/f056621f-fa0e-4c04-9209-ae9d51714c74-14899999.jpg",alt:"img"}})])]),e._v(" "),i("li",[i("p",[e._v("**生产者，消费者问题"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/7eb3b77e-ca21-4386-ae53-fd0d49d78455-14899999.jpg",alt:"img"}})])]),e._v(" "),i("li",[i("p",[e._v("Scheduler")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Short-term scheduler：CPU scheduler, 选择哪个进程将会被cpu执行")])]),e._v(" "),i("li",[i("p",[e._v("Long-term scheduler：job scheduler， 选择哪个进程将会被放到ready queue中"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/6a36a90e-5aeb-44c1-b562-d5a025e33896-14899999.jpg",alt:"img"}})])]),e._v(" "),i("li",[i("p",[e._v("Process分为：")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("I/O bound process：用更多的时间做IO操作，而不是CPU计算")])]),e._v(" "),i("li",[i("p",[e._v("CPU bound process：反之")])])])]),e._v(" "),i("li",[i("p",[e._v("另外还有medium scheduler，比如："),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/dc3f3008-3872-41b7-bfd0-b4c9aefbb595-14899999.jpg",alt:"img"}})])]),e._v(" "),i("li",[i("p",[i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/ad7afe99-832c-4e36-8d15-0eca190418fd-14899999.jpg",alt:"img"}})])])])]),e._v(" "),i("li",[i("p",[e._v("Process creation")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("父进程创建子进程，所以进程是一棵树")])]),e._v(" "),i("li",[i("p",[e._v("进程用pid进行标识")])])])]),e._v(" "),i("li",[i("p",[e._v("fork：克隆一份父进程的代码，从头开始执行，只不过fork函数在父进程中返回子进程的pid，在子进程中返回0")]),e._v(" "),i("ul",[i("li",[e._v("执行一次返回两个值")])])]),e._v(" "),i("li",[i("p",[e._v("exec：")]),e._v(" "),i("ul",[i("li",[i("p",[e._v('一个进程一旦调用exec类函数，它本身就"死亡"了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。（不过exec类函数中有的还允许继承环境变量之类的信息。）')])]),e._v(" "),i("li",[i("p",[e._v("那么如果我的程序想启动另一程序的执行但自己仍想继续运行的话，怎么办呢？那就是结合fork与exec的使用。"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/875752ff-8553-4d5f-987a-5c20f4076b4e-14899999.jpg",alt:"img"}}),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/3691449a-3f93-4eca-8c88-a98342301b9e-14899999.jpg",alt:"img"}})])])])]),e._v(" "),i("li",[i("p",[e._v("process termination")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("cascading termination：有些操作系统不允许子进程在父进程挂了的情况下继续执行")])]),e._v(" "),i("li",[i("p",[e._v("zombie process：没有父进程在wait")])]),e._v(" "),i("li",[i("p",[e._v("orphan process：父进程没有wait但是结束了")])])])]),e._v(" "),i("li",[i("p",[e._v("Interprocess communication")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Shared memory")])]),e._v(" "),i("li",[i("p",[e._v("message passing")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Synchronization")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Blocking--\x3esynchronize")])]),e._v(" "),i("li",[i("p",[e._v("non-blocking--\x3easynchronize")])])])]),e._v(" "),i("li",[i("p",[e._v("Buffering"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/4f835bfb-2b1c-436d-9dd6-4383f5c81e94-14899999.jpg",alt:"img"}})])])])]),e._v(" "),i("li",[i("p",[e._v("Pipe")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Ordinary pipe: 用于父进程与子进程之间的通信，其他进程不能访问，并且是单向的")]),e._v(" "),i("ul",[i("li",[e._v("Windows calls these anonymous pipes")])])]),e._v(" "),i("li",[i("p",[e._v("Named pipe: 用于其他进程之间的通信，可以多进程用一个管道，可以是双向的")])])])])])]),e._v(" "),i("li",[i("p",[e._v("Exercise：看ppt")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("pid：process id")])]),e._v(" "),i("li",[i("p",[e._v("ppid： parent process id，没有父进程就是0")])]),e._v(" "),i("li",[i("p",[e._v("tid：thread Id")])]),e._v(" "),i("li",[i("p",[e._v("tgid：thread group id：The ID of the process that started the threadhttps://blog.csdn.net/chenpu5887/article/details/100627310?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.essearch_pc_relevant&spm=1001.2101.3001.4242.1"),i("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/e47f5228-62bb-425d-bedf-327080d2e280-14899999.jpg",alt:"img"}})])]),e._v(" "),i("li",[i("p",[e._v("https://blog.csdn.net/qq_29503203/article/details/54618275")])])])])])])}),[],!1,null,null,null);i.default=p.exports}}]);