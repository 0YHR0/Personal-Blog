(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{452:function(t,v,_){"use strict";_.r(v);var l=_(2),s=Object(l.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"stack"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stack"}},[t._v("#")]),t._v(" Stack")]),t._v(" "),v("p",[v("strong",[t._v("复杂计算机的实现：")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("中缀转后缀")])]),t._v(" "),v("li",[v("strong",[t._v("计算后缀")])])]),t._v(" "),v("p",[v("strong",[t._v("中缀转后缀原则：")])]),t._v(" "),v("ul",[v("li",[t._v("两个栈，一个运算符栈，一个字母栈，运算符出栈前先出所有的字母栈")])]),t._v(" "),v("ul",[v("li",[t._v("当下一操作符的优先级高于栈顶操作符，入栈")]),t._v(" "),v("li",[t._v("当下一操作符的优先级低于栈顶操作符，一直出栈，直到遇到比其低级的操作符，再入栈")]),t._v(" "),v("li",[t._v("当  “（  ”  入栈时，具有最高的优先级，直接压入栈")]),t._v(" "),v("li",[t._v("当 “ （  ”  出栈时，具有最低的优先级，除非碰到  “ ）”，否则不会出栈")]),t._v(" "),v("li",[t._v("当读到“ )  ” 时，弹出栈中的操作符，直到遇到 “（”")])]),t._v(" "),v("p",[t._v("例：a + b * c + ( d * e + f ) * g")]),t._v(" "),v("p",[t._v("后缀：a b c * + d e * f + g * +")]),t._v(" "),v("p",[v("strong",[t._v("后缀计算原则：")])]),t._v(" "),v("ul",[v("li",[t._v("字母压入栈中，当遇到操作符时，弹出两个字母，并且把计算之后的数值继续压入栈中，以此类推")])])])}),[],!1,null,null,null);v.default=s.exports}}]);